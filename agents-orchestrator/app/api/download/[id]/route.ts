import { NextRequest, NextResponse } from 'next/server';
import { migrationResults } from '@/lib/utils/storage';
import archiver from 'archiver';

export const runtime = 'nodejs';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const migrationId = id;
    const result = migrationResults.get(migrationId);

    if (!result) {
      return NextResponse.json(
        { success: false, error: 'Migration not found' },
        { status: 404 }
      );
    }

    const { microservice } = result;

    // Create ZIP archive
    const archive = archiver('zip', {
      zlib: { level: 9 },
    });

    const chunks: Buffer[] = [];
    
    archive.on('data', (chunk: Buffer) => {
      chunks.push(chunk);
    });

    // Add all files
    microservice.files.forEach((file: any) => {
      archive.append(file.content, { name: file.path });
    });

    // Add Dockerfile
    archive.append(microservice.dockerfile, { name: 'Dockerfile' });

    // Add README
    const readme = `# ${microservice.serviceName}

${microservice.description}

## Language: ${microservice.language}
## Port: ${microservice.port}

## Dependencies
${microservice.dependencies.map((d: string) => `- ${d}`).join('\n')}

## Environment Variables
${microservice.environmentVariables.map((e: any) => `- ${e.key}: ${e.description}`).join('\n')}

## Build Instructions
${microservice.buildInstructions.map((i: string, idx: number) => `${idx + 1}. ${i}`).join('\n')}

## Run Instructions
${microservice.runInstructions.map((i: string, idx: number) => `${idx + 1}. ${i}`).join('\n')}

${microservice.testCommand ? `## Test\n\`\`\`bash\n${microservice.testCommand}\n\`\`\`\n` : ''}

## API Documentation
${microservice.apiDocumentation}

---
Generated by Monolith Migration Orchestrator
`;

    archive.append(readme, { name: 'README.md' });

    // Finalize archive
    await archive.finalize();

    // Wait for all chunks
    await new Promise(resolve => archive.on('end', resolve));

    const buffer = Buffer.concat(chunks);

    return new NextResponse(buffer, {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${microservice.serviceName}.zip"`,
        'Content-Length': buffer.length.toString(),
      },
    });
  } catch (error) {
    console.error('Download error:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Download failed',
      },
      { status: 500 }
    );
  }
}
